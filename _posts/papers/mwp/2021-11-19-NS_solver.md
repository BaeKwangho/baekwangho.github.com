---
title: "NS-solver 논문 후기"
layout: single
categories:
  - mwp
---

> seq2seq 시스템에서 벗어나 상징적인 관계를 학습할 수 있는 모델을 설계. 전단에서는 문제를 읽어 이해하고 뒷단에서 수식을 생성함. 그리고 수식을 실행기가 답을 도출하게 된다.

# 1. 서론
이전의 접근에서, 인코더는 문제를 실수의 벡터로 표현하기 위해 사용되고, 디코더는 새로운 NN으로써 수식을 생성하거나 표현을 토큰으로써 만들 수 있었다. 하지만 이는 주로 인코더-디코더 패러다임에서 벗어나지 못해, 상식적인 내용 혹은 수식 정규화 등을 수행하지 못하는 문제가 있었다.
수식을 예측하는 데에 있어 4개의 최적화 로스를 사용하였다고 함.

## 3.1 Backbone
reader는 주어진 문제의 수를 n1,n2 등으로 치환하고 이를 bi-gru를 사용하여 hidden representation으로 나타냄. programmer는 reader의 output과 representation을 초기 hidden state로 사용하고 equation tree 이전의 sequence로써 디코딩해준다. 모든 문제에서 programmer는 연산자, 변수, 상수, 문제에서 제시된 수를 포함한다.
executor로 sympy를 사용한다.

## 3.2  보조 작업 설계
(SNP)
수의 크기 예측과 위치 예측은 자기주도적 학습 방식에서 문제 의미론적 해석에 아주 큰 영향을 미친다.  모두 문제 인코더의 출력을 입력으로 하여 feed-forward nn을 통과시켜 얻을 수 있다.
수식 (1)에서 Q와 L은 최대 가능한 수의 크기 및 최대 가능한 수의 위치이다. 
(CCP)
상식적 상수는 이전에는 수로만 다루어졌다. 하지만 상수를 예측하기 위해 후보군을 많이 두면 search space가 늘어나는 문제가 생긴다. (equation tree 생성에 직접적인)  SNP와 같이 문제 인코더의 출력을 입력으로 하고, ffnn을 통과시켜 constant에 대한 확률 분포를 얻는다. 정확하지 않기에, 예측되지 않은 3개의 추가 constant로써 search space를 줄이고 정확도를 높일 수 있다.
(PCC)
문제가, 같지만 다른 수식이 존재할 수 있음으로 예측된 수식이 label 수식과 의존적이어야 한다.  y_i에 대한 확률 분포를 계산함으로써 이를 학습되도록 한다.
(DE)
문제 생성과 문제 해결의 관계에 기인하여, symbol 기반의 문제 생성과 문제의 품사 생성 간의 준이중성을 사용하여 개선하는 방법을 소개한다. 
문제 p와 그의 수식 T에 대해 P'는 P의 품사이다. P'와 T의 확률은 한계분포이고 이는 LSTM 기반 LM으로 설계할 수 있다. GTS의 트리 구조 인코더를 수식을 POS 생성을 위해 사용한다.